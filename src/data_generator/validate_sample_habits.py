# Habit Data Validator GENERATED by Claude.ai

import csv
from datetime import datetime, timedelta


def validate_habit_data(filename):
    with open(filename, 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        # current_date = datetime(2024, 9, 24, 23, 59, 59)
        # ! Adjust current time conf when necessary
        current_date = datetime.now().replace(
            hour=23, minute=59, second=59, microsecond=0) - timedelta(days=1)
        # Start at 2 to account for header row
        for row_number, row in enumerate(reader, start=2):
            try:
                name = row['name']
                periodicity = row['periodicity']
                current_streak = int(row['current_streak'])
                longest_streak = int(row['longest_streak'])
                next_completion_date = datetime.strptime(
                    row['next_completion_date'], "%Y-%m-%d %H:%M:%S")
                created_at = datetime.strptime(
                    row['created_at'], "%Y-%m-%d %H:%M:%S")
                updated_at = datetime.strptime(
                    row['updated_at'], "%Y-%m-%d %H:%M:%S")

                # Check if periodicity is valid
                if periodicity not in ['daily', 'weekly']:
                    print(f"Row {row_number}: Invalid periodicity for {name}")

                # Check if created_at is before or equal to current_date
                if created_at > current_date:
                    print(
                        f"Row {row_number}: Created date is in the future for {name}")

                # Check if updated_at is equal to created_at
                if updated_at != created_at:
                    print(
                        f"Row {row_number}: Updated date should be equal to created date for {name}")

                # Calculate maximum possible streak based on the time since creation
                days_since_creation = (current_date - created_at).days + 1
                if periodicity == 'daily':
                    max_possible_streak = days_since_creation
                else:  # weekly
                    weeks = days_since_creation // 7
                    max_possible_streak = weeks + 1  # Include the current week

                # Check if current_streak and longest_streak are consistent
                if current_streak > longest_streak:
                    print(
                        f"Row {row_number}: Current streak is greater than longest streak for {name}")

                # Check if longest streak is realistic based on max_possible_streak
                if longest_streak > max_possible_streak:
                    print(
                        f"Row {row_number}: Longest streak exceeds maximum possible streak for {name}")

                # Validate next_completion_date logic
                expected_next_completion = None
                if periodicity == 'daily':
                    expected_next_completion = current_date + timedelta(days=1)
                else:  # weekly
                    # Use the last known activity date (either created or updated)
                    last_known_activity = max(created_at, updated_at)

                    # Calculate the offset from the creation weekday
                    weekday_offset = (
                        last_known_activity.weekday() - current_date.weekday()) % 7

                    # Ensure it is positive (meaning next occurrence)
                    if weekday_offset == 0:
                        weekday_offset = 7

                    expected_next_completion = current_date + \
                        timedelta(days=weekday_offset)

                # Compare the expected next completion date with the one in the data
                if next_completion_date.date() != expected_next_completion.date():
                    print(
                        f"Row {row_number}: Incorrect next completion date for {name}. Expected: {expected_next_completion.date()}, Found: {next_completion_date.date()}")
            except ValueError as e:
                print(f"Row {row_number}: Data format error - {e}")
    return True, "All habits are valid."
