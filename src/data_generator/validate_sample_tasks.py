# Generated by ChatGPT

import csv
import datetime


def load_habit_data(habits_csv):
    """
    Load habit data from the habits CSV file.

    habits_csv: Path to the habits CSV file
    """
    habit_data = {}
    with open(habits_csv, newline='') as file:
        reader = csv.DictReader(file)
        for row in reader:
            habit_data[row['id']] = {
                "periodicity": row['periodicity'],
                "current_streak": int(row['current_streak']),
                "longest_streak": int(row['longest_streak']),
                "created_at": datetime.datetime.strptime(row['created_at'], "%Y-%m-%d %H:%M:%S")
            }
    return habit_data


def validate_task_entries_from_csv(tasks_csv, habits_csv):
    """
    Validate the task entries from a tasks CSV file using information from the habits CSV file.

    tasks_csv: Path to the CSV file containing the task entries
    habits_csv: Path to the CSV file containing the habit entries
    """
    task_entries = []
    habit_data = load_habit_data(habits_csv)

    # Read task entries from CSV
    with open(tasks_csv, newline='') as file:
        reader = csv.DictReader(file)
        for row in reader:
            task_entries.append({
                "habit_id": row['habit_id'],
                "completed": row['completed'].lower() == 'true',
                "completed_on": datetime.datetime.strptime(row['completed_on'], "%Y-%m-%d %H:%M:%S") if row['completed_on'] else None,
                "expected_completion_by": datetime.datetime.strptime(row['expected_completion_by'], "%Y-%m-%d %H:%M:%S"),
                "created_at": datetime.datetime.strptime(row['created_at'], "%Y-%m-%d %H:%M:%S"),
                "updated_at": datetime.datetime.strptime(row['updated_at'], "%Y-%m-%d %H:%M:%S")
            })

    errors = []

    # Sort the tasks by expected completion date to make validation easier
    task_entries.sort(key=lambda x: x['expected_completion_by'])

    # Validate each task entry by habit
    for habit_id, habit_info in habit_data.items():
        habit_tasks = [
            task for task in task_entries if task['habit_id'] == habit_id]
        current_streak = habit_info['current_streak']
        longest_streak = habit_info['longest_streak']
        periodicity = habit_info['periodicity']
        created_at = habit_info['created_at']

        # Extract tasks that are marked as completed
        completed_tasks = [task for task in habit_tasks if task['completed']]
        current_streak_tasks = []
        longest_streak_tasks = []

        # Validate that the current streak is recent and consecutive
#         print(habit_tasks)
#         print(habit_tasks[:-2])
        if current_streak > 0:
            for task in reversed(habit_tasks[:-1]):
                if len(current_streak_tasks) >= current_streak:
                    break
                if task['completed']:
                    current_streak_tasks.append(task)
                else:
                    break  # Current streak should be consecutive

            if len(current_streak_tasks) != current_streak:
                errors.append(
                    f"Habit {habit_id}: Current streak should be {current_streak}, but only found {len(current_streak_tasks)}.")

        # Validate that the longest streak is consecutive and non-overlapping unless current_streak == longest_streak
        if longest_streak > 0:
            potential_streak = []
            for i, task in enumerate(habit_tasks):
                if task['completed']:
                    potential_streak.append(task)
                    if len(potential_streak) == longest_streak:
                        if current_streak == longest_streak:
                            longest_streak_tasks = potential_streak
                        elif any(tsk in current_streak_tasks for tsk in potential_streak):
                            errors.append(
                                f"Habit {habit_id}: Longest streak overlaps with current streak.")
                        else:
                            longest_streak_tasks = potential_streak
                        break
                else:
                    potential_streak = []

            if len(longest_streak_tasks) != longest_streak:
                errors.append(
                    f"Habit {habit_id}: Longest streak should be {longest_streak}, but found {len(longest_streak_tasks)}.")

        # Validate that completed_on times are within the correct range
        for task in completed_tasks:
            completed_on = task['completed_on']
            expected_completion_by = task['expected_completion_by']
            time_lower_bound = datetime.datetime.combine(
                expected_completion_by.date(), datetime.time(1, 0, 0))

            # If it's the first task, the time must be between the created_at time and 23:59:59
            if expected_completion_by == habit_tasks[0]['expected_completion_by']:
                time_upper_bound = datetime.datetime.combine(
                    expected_completion_by.date(), datetime.time(23, 59, 59))
                time_lower_bound = max(time_lower_bound, created_at)
            else:
                time_upper_bound = datetime.datetime.combine(
                    expected_completion_by.date(), datetime.time(23, 59, 59))

            if not (time_lower_bound <= completed_on <= time_upper_bound):
                errors.append(
                    f"Habit {habit_id}: Completed_on time for task on {expected_completion_by} is out of bounds: {completed_on}.")

        # Validate that updated_at equals completed_on for completed tasks
        for task in habit_tasks:
            if task['completed'] and task['updated_at'] != task['completed_on']:
                errors.append(
                    f"Habit {habit_id}: Task should have updated_at equal to completed_on.")
            if not task['completed'] and task['updated_at'] != task['created_at']:
                errors.append(
                    f"Habit {habit_id}: Task should have updated_at equal to created_at.")

    # Return the results of validation
    if errors:
        return False, errors
    return True, "All tasks are valid."
